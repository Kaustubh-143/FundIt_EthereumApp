const assert = require('assert');
const ganache = require('ganache-cli');
const Web3= require('web3');

const web3 = new Web3(ganache.provider());

const compiledCampaign = require('../ethereum/build/ Campaign.json');
const compiledFactory = require('../ethereum/build/ CampaignFactory.json') ;

let accounts;
let campaign;
let factory;
let campaignAddress;

beforeEach(async () => {
    accounts = await web3.eth.getAccounts();

    factory = await new web3.eth.Contract(JSON.parse(compiledFactory.interface))
    .deploy({data: compiledFactory.bytecode})
    .send({from : accounts[0], gas:'1000000'}) ;

     await factory.methods.createCampaign('100').send({
         from:accounts[0],
        gas:'1000000',
     });

     const addresses = await factory.methods.getDeployedCampaigns().call();
     campaignAddress = addresses[0];

     campaign = await new web3.eth.Contract(JSON.parse(compiledCampaign.interface),campaignAddress);  //campaign is the representation of the already deployed contract that exists on the campaignAddress

})

describe('Campaign', () => {
    it('factory deployed',() => {
        assert.ok(factory.options.address);
    })

    it('campaign deployed',() => {
       assert.ok(campaign.options.address);
   })

   it('manager test', async () => {
       const manager = await campaign.methods.manager().call();
       assert.equal(accounts[0],manager);
   })

   it('Contribute test', async () => {
    await campaign.methods.contribute().send({
        from: accounts[1], 
        value:'200',
    })

    const isContributor = await campaign.methods.approvers(accounts[1]).call(); // we cannot retrieve an entire mapping, it just doesn't exist-- what we can do is we can pass a key to the mapping function generated by solidity and it will return if its true or false
    assert(isContributor) ;
})

   it('requires a minimum contribution' , async () => {
       try {

        await campaign.methods.contribute().send({
            from: accounts[1], 
            value:'0',
        })

        assert(false) ; // if this line of code is ever executed, we want the test to fail
           
       } catch (error) {
           assert(error);
       }
   })

   it('test create request', async () => {

       await campaign.methods
       .createRequest('to vendor','20',accounts[2])
       .send({from: accounts[0], gas:'1000000'})

       const request = await campaign.methods.requests(0).call() ; 
       assert.equal('to vendor',request.description);
   })

   it('end to end test' , async () => {

       const initialBalance = await web3.eth.getBalance(accounts[2]);
       await campaign.methods.contribute().send({from: accounts[1],value:web3.utils.toWei('10','ether')}) ;
       await campaign.methods.createRequest('to vendor',web3.utils.toWei('5','ether'),accounts[2]).send({from:accounts[0],gas:'1000000'}) ;
    //    const request = await campaign.methods.requests(0).call() ;
       await campaign.methods.approveRequest(0).send({from:accounts[1],gas:'1000000'}) ;
       await campaign.methods.finalizeRequest(0).send({from:accounts[0],gas:'1000000'}) ;

       const finalBalance = await web3.eth.getBalance(accounts[2]) ;

       let diff = finalBalance - initialBalance ; 
       diff = diff.toString();

       let balDiff = web3.utils.fromWei(diff,'ether') ;  //balDiff is gonna be a string

       balDiff = parseFloat(balDiff) ;

    //    console.log(balDiff); 
       
       assert(balDiff==5) ;

   })

})